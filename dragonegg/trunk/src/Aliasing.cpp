//=----------- Aliasing.cpp - Type-based alias analysis metadata ----------*-=//
//
// Copyright (C) 2012  Duncan Sands.
//
// This file is part of DragonEgg.
//
// DragonEgg is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software
// Foundation; either version 2, or (at your option) any later version.
//
// DragonEgg is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
// A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along with
// DragonEgg; see the file COPYING.  If not, write to the Free Software
// Foundation, 51 Franklin Street, Suite 500, Boston, MA 02110-1335, USA.
//
//===----------------------------------------------------------------------===//
// This file declares routines for generating TBAA metadata from what GCC knows
// about pointer aliasing.
//===----------------------------------------------------------------------===//

// Plugin headers
#include "dragonegg/Aliasing.h"

// LLVM headers
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/Twine.h"
#include "llvm/LLVMContext.h"
#include "llvm/Metadata.h"
#include "llvm/ADT/EquivalenceClasses.h"

// System headers
#include <gmp.h>
#include <map>

// GCC headers
extern "C" {
#include "config.h"
// Stop GCC declaring 'getopt' as it can clash with the system's declaration.
#undef HAVE_DECL_GETOPT
#include "system.h"
#include "coretypes.h"
#include "tm.h"
#include "tree.h"

#include "alias.h"
}

// Trees header.
#include "dragonegg/Trees.h"

using namespace llvm;

static LLVMContext &Context = getGlobalContext();

/// getTBAARoot - Return the root of the TBAA tree for this compilation unit.
static MDNode *getTBAARoot() {
  static MDNode *Root;
  if (!Root) {
    // Create the root node.  This must be unique to the compilation unit since
    // the names of the nodes we hang off it have no intrinsic meaning: nodes
    // from different compilation units must not be merged even if they have the
    // same name.  To ensure uniqueness the root node is made self-referential.
    MDNode *Dummy = MDNode::getTemporary(Context, ArrayRef<Value*>());
    Root = MDNode::get(Context, Dummy);
    // At this point we have
    //   !0 = metadata !{}            <- dummy
    //   !1 = metadata !{metadata !0} <- root
    // Replace the dummy operand with the root node itself and delete the dummy.
    Root->replaceOperandWith(0, Root);
    MDNode::deleteTemporary(Dummy);
    // We now have
    //   !1 = metadata !{metadata !1} <- self-referential root
  }
  return Root;
}

/// describeAliasSet - Return TBAA metadata describing what a load from or store
/// to the given tree may alias.
MDNode *describeAliasSet(tree t) {
  alias_set_type alias_set = get_alias_set(t);
  // Alias set 0 is the root of the alias graph and can alias anything.  A
  // negative value represents an unknown alias set, which as far as we know
  // may also alias anything.
  if (alias_set <= 0)
    return 0;

  // The difficulty here is that GCC's alias sets are the nodes of a directed
  // acyclic graph (DAG) rooted at 0, and in complicated cases it really is a
  // DAG and not a tree.  On the other hand, LLVM requires TBAA nodes to form
  // a tree.  In short we need to come up with a tree and a graph map (i.e. a
  // map that takes nodes to nodes and edges to edges) from GCC's DAG to this
  // tree.  An additional difficulty is that we don't actually know the edges
  // in the DAG: GCC's alias analysis interface does not expose them.  All that
  // we have is alias_set_subset_of(s, t) which returns true iff there is a path
  // from t to s in the DAG. Finally, we don't know the nodes of the DAG either!
  // We only discover them progressively as we convert functions.
  // For the moment we take a very simple approach: the TBAA tree will be only
  // one level deep: a list of nodes hanging off the root node.  This is not a
  // good choice in general: it is perfectly possible for a huge alias DAG to
  // result in just one node hanging off the root.  But it is simple.  We keep
  // a collection of disjoint sets of DAG nodes seen so far.  The sets represent
  // the equivalence relation generated by requiring A and B to be in the same
  // equivalence class if there is a path from A to B or from B to A.
  typedef EquivalenceClasses<alias_set_type> DisjointSets;
  static DisjointSets Nodes; // The TBAA nodes hanging off the root.
  static std::map<alias_set_type, MDNode*> NodeTags; // Node -> metadata map.

  // If alias_set was already seen then return the previously computed metadata.
  DisjointSets::member_iterator MI = Nodes.findLeader(alias_set);
  if (MI != Nodes.member_end()) {
    assert(NodeTags.find(*MI) != NodeTags.end() && "Node has no metadata!");
    return NodeTags[*MI];
  }

  // Examine all previously seen nodes and determine which of them, if any, may
  // alias alias_set.
  SmallVector<DisjointSets::member_iterator, 8> MayAlias;
  for (DisjointSets::iterator I = Nodes.begin(); I != Nodes.end(); ++I)
    for (DisjointSets::member_iterator MI = Nodes.member_begin(I),
         ME = Nodes.member_end(); MI != ME; ++MI)
      if (alias_sets_conflict_p(alias_set, *MI)) {
        // May alias - remember this and move on to the next node.
        MayAlias.push_back(Nodes.findLeader(I));
        break;
      }

  // If none of the existing nodes may be aliased, then create a new node.
  if (MayAlias.empty()) {
    // Create metadata describing a new node hanging off root.  The name doesn't
    // matter much but needs to be unique for the compilation unit.
    std::string TreeName = ("alias set " + Twine(alias_set) + ": " +
      getDescriptiveName(TYPE_CANONICAL(main_type(t)))).str();
    Value *Ops[2] = { MDString::get(Context, TreeName), getTBAARoot() };
    MDNode *AliasTag = MDNode::get(Context, Ops);
    NodeTags[alias_set] = AliasTag;
    // Remember the new node in the equivalence relation.
    Nodes.insert(alias_set);
    return AliasTag;
  }

  // Merge all of the nodes that may alias alias_set into one node.
  DisjointSets::member_iterator TheChosenOne = MayAlias[0];
  MDNode *TheChosenTag = NodeTags[*TheChosenOne];
  for (unsigned i = 1, e = MayAlias.size(); i != e; ++i) {
    DisjointSets::member_iterator Leader = MayAlias[i];
    MDNode *AliasTag = NodeTags[*Leader];
    // Use the chosen node's TBAA metadata instead of this node's.
    AliasTag->replaceAllUsesWith(TheChosenTag);
    NodeTags.erase(*Leader);
    // Merge this node into the chosen node.
    Leader = Nodes.unionSets(TheChosenOne, Leader);
    assert(Leader == TheChosenOne && "Union mutated chosen leader!");
  }
  // Add alias_set itself to the merged node.
  Nodes.unionSets(TheChosenOne, Nodes.findLeader(Nodes.insert(alias_set)));

  // Finally, return the metadata for the merged node.
  return TheChosenTag;
}
