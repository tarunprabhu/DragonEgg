#!/bin/bash

# This script performs an automated self-hosted build of dragonegg.  In
# other words it builds dragonegg, then builds GCC and LLVM with dragonegg,
# then uses those and dragonegg to rebuild dragonegg.  It does this a couple
# of times until it reckons you must be fed up.  At which point it checks
# that the dragonegg plugin is not changing at each iteration.
#
# This is all extreme overkill if all you want to do is try out dragonegg!  If
# that's your goal then I suggest you consult the README file one directory up.

DRAGONEGG_DIR=$PWD/dragonegg

GCC_SRC_DIR=$PWD/gcc
GCC_OBJ_DIR=$PWD/gcc-objects
GCC_INS_DIR=$PWD/gcc-install

LLVM_SRC_DIR=$PWD/llvm
LLVM_OBJ_DIR=$PWD/llvm-objects


COMPARE="cmp --ignore-initial=16"
GCC_OPTIONS="--enable-lto --enable-languages=c,c++ --disable-bootstrap --disable-multilib --enable-checking"
LLVM_OPTIONS="--enable-optimized --enable-assertions"
MAKE="nice -n 20 make -j2"
STAGES="0 1 2"


set -o errexit    # Exit if any command fails
shopt -s nullglob


# Check out or update the dragonegg source
if [ -a $DRAGONEGG_DIR ] ; then
  echo "Updating dragonegg"
  svn update $DRAGONEGG_DIR
else
  echo "Checking out dragonegg"
  svn co http://llvm.org/svn/llvm-project/dragonegg/trunk $DRAGONEGG_DIR
fi


# Check out or update the LLVM source
if [ -a $LLVM_SRC_DIR ] ; then
  echo "Updating LLVM"
  svn update $LLVM_SRC_DIR
else
  echo "Checking out LLVM"
  svn co http://llvm.org/svn/llvm-project/llvm/trunk $LLVM_SRC_DIR
fi


# Check out or update the GCC source
if [ -a $GCC_SRC_DIR ] ; then
  echo "Reverting any applied patches"
  svn revert -R $GCC_SRC_DIR/gcc
  echo "Updating GCC"
  svn update $GCC_SRC_DIR
else
  echo "Checking out GCC"
  svn co svn://gcc.gnu.org/svn/gcc/trunk $GCC_SRC_DIR
fi


# Apply any needed patches to GCC
for PATCH in $DRAGONEGG_DIR/gcc-patches/*.diff ; do
  echo "Applying patch $PATCH"
  patch -d $GCC_SRC_DIR -p1 < $PATCH
done

PLUGIN_OPTION= # No plugin yet
PREV_STAGE= # No previous stage
for STAGE in $STAGES ; do

  # ==> begin: Build and install GCC
  echo "Building stage $STAGE GCC"
  echo "Cleaning out old GCC build"
  rm -fr $GCC_OBJ_DIR
  mkdir -p $GCC_OBJ_DIR
  cd $GCC_OBJ_DIR

  echo "Configuring stage $STAGE GCC"
  $GCC_SRC_DIR/configure --prefix=$GCC_INS_DIR $GCC_OPTIONS

  echo "Compiling stage $STAGE GCC"
  $MAKE

  echo "Installing stage $STAGE GCC"
  $MAKE install
  # <== end: Build and install GCC


  # From now on compile using the newly built GCC
  export CC="$GCC_INS_DIR/bin/gcc $PLUGIN_OPTION"
  export CXX="$GCC_INS_DIR/bin/g++ $PLUGIN_OPTION"
  export GCC=$CC # Tells dragonegg what to build against

  # The built libstdc++ and libgcc may be more recent than the system versions.
  # Set the library path so that programs compiled with the just built GCC will
  # start successfully, rather than failing due to shared library dependencies.
  export LD_LIBRARY_PATH=`$CC -print-search-dirs | grep "^libraries:" | sed "s/^libraries: *=//"`:$LD_LIBRARY_PATH


  # ==> begin: Build LLVM using the just built GCC
  echo "Building stage $STAGE LLVM"
  echo "Cleaning out old LLVM build"
  rm -fr $LLVM_OBJ_DIR
  mkdir -p $LLVM_OBJ_DIR
  cd $LLVM_OBJ_DIR

  echo "Configuring stage $STAGE LLVM"
  $LLVM_SRC_DIR/configure $LLVM_OPTIONS

  echo "Compiling stage $STAGE LLVM"
  $MAKE
  # <== end: Build LLVM using the just built GCC


  # From now on 'llvm-config' will be the just built one.
  export LLVM_CONFIG=$LLVM_OBJ_DIR/*/bin/llvm-config


  # ==> begin: Build dragonegg using the just built GCC and LLVM.
  echo "Building pre-stage $STAGE dragonegg"
  cd $DRAGONEGG_DIR
  $MAKE clean
  $MAKE
  echo "Plugin is dragonegg.latest.so"
  cp dragonegg.so dragonegg.latest.so
  # <== end: Build dragonegg using the just built GCC and LLVM.


  # From now on compile using the latest dragonegg
  PLUGIN_OPTION="-fplugin=$DRAGONEGG_DIR/dragonegg.latest.so"
  export CC="$GCC_INS_DIR/bin/gcc $PLUGIN_OPTION"
  export CXX="$GCC_INS_DIR/bin/g++ $PLUGIN_OPTION"
  export GCC=$CC # Tells dragonegg what to build against


  # ==> begin: Build dragonegg again using the just built dragonegg
  echo "Building stage $STAGE dragonegg with itself"
  cd $DRAGONEGG_DIR
  $MAKE clean
  $MAKE
  echo "Plugin is dragonegg.latest.so"
  cp dragonegg.so dragonegg.latest.so
  # <== end: Build dragonegg again using the just built dragonegg


  # ==> begin: Compare the dragonegg objects with those from the previous stage
  if [ "x$PREV_STAGE" != "x" ] ; then
    echo "Comparing stage $STAGE dragonegg objects to stage $PREV_STAGE objects"
    cd $DRAGONEGG_DIR
    for O in *.o ; do
      P=stage-$PREV_STAGE-objects/$O
      echo "$O vs $P"
      $COMPARE $O $P
    done
  fi
  # <== end: Compare the dragonegg objects with those from the previous stage


  # ==> begin: Save a copy of the plugin and the object files use to make it.
  cd $DRAGONEGG_DIR

  echo "Self built dragonegg is dragonegg.$STAGE.so"
  cp dragonegg.so dragonegg.$STAGE.so

  SAVED_OBJECTS_DIR=stage-$STAGE-objects/
  echo "Moving objects to $SAVED_OBJECTS_DIR"
  rm -fr $SAVED_OBJECTS_DIR
  mkdir $SAVED_OBJECTS_DIR
  mv *.o $SAVED_OBJECTS_DIR
  # <== end: Save a copy of the plugin and the object files use to make it.

  PREV_STAGE=$STAGE
done
